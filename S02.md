#Solutions S02
##Questions de bases
1. Voici le programme complet qui affiche le nombre de bytes utilisés par chaque type de donnée demandé dans l'énoncé :
  ```c
  #include <stdlib.h>
  #include <stdio.h>
  #include <stdint.h>
  
  int main(void)
  {
    // %zd est le format de printf pour size_t, qui est le type retourné par
    // sizeof()
    printf("int:\t\t%zd bytes\n", sizeof(int));
    printf("long:\t\t%zd bytes\n", sizeof(long));
    printf("void *:\t\t%zd bytes\n", sizeof(void *));
    printf("char *:\t\t%zd bytes\n", sizeof(char *));
    printf("size_t:\t\t%zd bytes\n", sizeof(size_t));
    printf("uint64_t:\t%zd bytes\n", sizeof(uint64_t));

    return EXIT_SUCCESS;
  }
  ```
  
  [TODO] Se connecter à sirius via SSH est laissé en exercice au lecteur.

2. Une solution parmi tant d'autre
  ```c
  int getLeastSignificantBit(int number) {
  
    // Petite verification pour eviter une boucle infinie
    if (number == 0)
      return 0;
  
    int i = 0;
    
    // On regarde si le premier bit du nombre n'est pas 1
    while ((number & 0b1) != 0b1) {
  
      // On décale le bit vers la droite
      number = number >> 1;
      i++;
    }
    
    // i vaut la position du premier bit significatif
    // pour trouver la valeur de ce bit, il suffit de faire base ^ position
    return pow(2, i);
  }
  ```

3. Les deux manières différentes d'afficher le contenu de la chaine de caractères sont les suivantes :
  
  - En considérant `ptr` comme un tableau de `char` : on utilise `strlen` pour calculer la longueur de la chaine de caractère, puis on parcours `ptr` dans une boucle `for`.
    
    ```c
    int longueur = strlen(ptr);
    for (int i = 0; i < longueur; i++)
      printf("%p:\t%c\n", &ptr[i], ptr[i]);
    ```
    
  - En utilisant l'arithmétique des pointeurs : comme la chaine de caractères est stockée de manière contiguë en mémoire, on peut parcourir celle-ci en incrémentant le pointeur `ptr`, qui va donc successivement pointer vers le premier caractère, puis le deuxième, etc. On utilise une boucle `while` qui se termine lorsque la valeur pointée par `ptr`, c'est-à-dire `*ptr`, est égale à `'\0'`, le marqueur de fin de chaine de caractères.
    
    ```c
    while (*ptr != '\0') {
      printf("%p:\t%c\n", ptr, *ptr);
      ptr++; // Incrémenter ptr pour pointer vers le caractère suivant
    }
    ```

4. [TODO]

5. De prime abord, on pourrait simplement penser que la taille d'une structure est égale à la somme des tailles de ses composantes.
  Autrement écrit:
  ```c
  sizeof(foo_t) == sizeof(char) + sizeof(int)
  ```
  
  Seulement, si on execute un code qui affiche la taille de la structure, on verra que celle-ci est légèrement plus grande.
  En recherchant rapidement sur Google, on trouve [ceci](http://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member) comme explication.
