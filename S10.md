#Solutions S10
##Exercices
1. 
  ```c
  #include <signal.h>
  #include <stdbool.h>
  
  int sig_ignored(int signum){
    struct sigaction *old = NULL;
    const void * bl;
    sigaction(signum,NULL,old);
    bl = old->sa_handler;
      if(bl == SIG_IGN || bl == SIG_ERR){ 
        return true;
      } else {
        return false;
      }
  }
  ```

2. Le système d'exploitation refuse car il n'est pas autorisé de changer le signal handler de `SIGKILL`.

3. On pourrait par exemple ignorer le signal `SIGINT`. Cela se ferai de la manière suivante :
  ```c
  // Quelque-part au début du programme (par exemple premières lignes de main)
  signal(SIGINT, SIG_IGN);
  ```

4. Ce programme ne résoud pas le problème. En effet, il est possible que le processus avance jusque dans le `if`, puis soit bloqué par le système d'exploitation pendant plus de 5 secondes avant d'exécuter l'appel système `read`. Dans ce cas, changer la valeur de `expired` à `true` n'empêchera pas le programme de bloquer indéfiniment sur `read`. Cela est par contre évité dans la solution du syllabus grâce à `siglongjmp`.

5. - Le signal `SIGSYS` est généré lorsqu'un processus effectue un appel système avec des arguments erronés.
   - Le signal `SIGPIPE` est généré lorsqu'un processus tente d'écrire dans une pipe qui n'est pas ouverte en lecture.

6. Cela permet au processus père de continuer son exécution sans devoir attendre que ses fils se terminent avec `waitpid`, qui est bloquant. Il peut simplement définir un handler pour le signal `SIGCHLD` qui exécute (éventuellement plusieurs fois, avec l'option `WNOHANG`, au cas où plusieurs fils auraient terminé) l'appel système `waitpid`.

7. Lorsqu'un processus est en train d'exécuter la fonction de traitement d'un signal, celui-ci est nécessairement bloqué. Le signal `SIGUSR1` ne sera donc pas traité. Par contre, les autres signaux ne sont pas bloqués, et donc envoyer un signal `SIGUSR2` interrompera le traitement du signal `SIGUSR1` pour traiter ce nouveau signal, puis reviendra au traitement de `SIGUSR1` pour terminer.

8. Il suffit d'enregistrer la valeur de `errno`, puis de la restaurer à la fin du handler :
  ```c
  static void sig_handler(int signum) {
    int errno_bak = errno; // On enregistre la valeur précédente de errno...
    char *msg="Reçu signal \n";
    write(STDERR_FILENO, msg, strlen(msg));
    errno = errno_bak; // ...puis on la restaure 
  }
  ```

9. [TODO]

10. [TODO]

11. [TODO]

12. [TODO]

13. [TODO]
